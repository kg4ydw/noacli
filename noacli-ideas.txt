async shell
noacli -- no ampersand
sash steves asynchronous shell

o  started, partial implementation
*  done
!/ next
E  buggy
-  gui implelemented, no code
x  not supported in Qt


Things to implement soon:
? close stdin
  job: double click connect to send command to editor
o job life cycle
*   connect to qtail window status
*   delete job if command is done and window is closed
    timeout if no window?
* tables: implement vertical headers??
*   make corner button clickable to reset sort column to -1
* qtail: resize after visible? or after first read

  command parser
    prefix or suffix for output dest
      stdout:stderr
      > @qtail  2>@qtail
      default qtail:log
    handle |  --> tree
    handle <
    handle >
    set window title based on regex filter list
  update status bar with recent process status and errors
  short output in status window
  single lines to status bar (and status window?)

  job manager and hsitory:
    scroll to new entry
    resize columns

Bugs:
* gets middle of file on /usr/dict/words without --whole
? what to do with stderr? always log?
FIXED Qt doesn't support pipes (test in non-linux)
* history disconnect for old entry with running command
  Traceback (most recent call last):
    File "./noacli.py", line 90, in runCommand
      j = jobItem(hist)
    File "/home/ssd/src/noacli/datamodels.py", line 48, in __init__
      self.setStatus('init')
    File "/home/ssd/src/noacli/datamodels.py", line 70, in setStatus
      self.history.model().setStatus(self.history,status)
  AttributeError: 'QSortFilterProxyModel' object has no attribute 'setStatus'



Main features:
  main window is a dynamic one line editor
*   complex commands are sent to bash
      detect complex commands
    command window context menu
      run
      clear?
      save to favorites
    Qsettings
       save/restore geometry (QWidget)
         save multiple profiles
/      save/restore history?
       save env changes?
    docks* and +dialogs?  (%hash @array)
      dock: QT data structure is persistent and master
      dialog: build a table on the fly and save changes
*      *@ history
-      *% button bar
 	    right click: dump in editor
	    draggable gridview ??
	    reimplement compact button bar GUI and make its own checkbox
*      *? job manager
       !@ favorites editor (buttons and frequent)
       !% environment var editor
       !% settings editor
       !% command default mode editor
            table: command mode
	    mode: qtail log terminal null local graph (default: pulldown)
*   history with arrow keys
    history search with ctrl-s ctrl-r and !?
    history with pull down menu (last 10)
    history manager
o     table: index frequency exitval command button-name checkbox:edit/run
*     editable table --> double click to edit in main window
*     exit value: none if never run; color green/red/grey
E     allow re-edits of unrun entries, move to end of list
*     sortable table (by col)
*     search box --> filter
*     sort: history order (col=-1)
      context menu
    remember 10 most frequent commands in pull down menu
    button editor ("favorites")
      lists current buttons
      includes frequent history (sort by freq, cmd [hindex] )
      mark edited lines and save? or just mark to keep or expire
      table: name count command checkImmediate keyshortcut
      context menu: delete, duplicate?, run?
      buttons: apply prune

    history context menu
/     (single click copies to edit window, double click runs)
      add to favorites
      edit favorite --> favorite dialog box with entry selected?
      delete
      mark commands in favorites?
      mark frequent commands?
    job manager list
o     manager table: pid type command kill raise? info rerun
*     alternate: QProcess object, status, type, command
      window status / type?
*     click to redisplay / raise window (qtail)
      context menu:
        info? --> process status, time stats, etc
	kill
	edit
	kill or kill and restart
o	raise or reopen
	close window
	measure output
	clone?
      open status icon
*     proc/wait info
*     delete dead jobs? (life cycle)
      change default type
    job / process manager
      handle stdout
        stderr channels separately
	save to file
      handle stdin:
        send file
	pipe  (connect multiple commands, tree style jobs)
!       close when not used
!   settings
      table: name default tooltip currentval
      merge qtail options
      items
!	historysize
	historyfile
	recent menu size
	frequent menu size
	frequents size
!	external shell
	graphical terminal
      environment vars?
        inherit for subprocs (active)
	inherited / modified
 	save / session

  short output commands -- display last line in editor/launcher


  terminal
o qtail window
  graphical window -- merged logs?
! merged log viewer
  table parser window
  iconified -- status from proc
  special -- parsed status
    pie chart for percentages / apt interaction
  ephemeral -- autoclose

o scrolly window
*   view / follow a log file
*   take input from a pipe
E   keep only last X lines? (initial input overload)
*   autoresize (need trigger event)
    in a file, button to backscroll to previous lines or read more forward
       large file handling, line number / fseek index
*   start from top / follow tail
o   reload button
*     if file --> reload
*     if process / running command -> kill
!     if done command -> rerun
/     if open stdin -> stop (close)
/     if closed -> close window
    autoclose after exit on specified timeout without user interaction
*   search / filter ?
    search context menu
o     find next
      find previous
      advanced --> find dialog
    menu bar
      file
        open: new / command / reopen/refresh / rerun / reopen file in other app
        save as
        buffering: tail [size] / all
        format/view
**x       plain text html markdown
/         fixed width font
o     memory saver (limit scrollback to 1M / 10000 lines by default)
      find menu
        advanced --> find dialog
*       wrap?
        bookmarks
      find dialog
        buttons: next prev hilight/unhilight
        regex / glob / plain ?
o       ignore case (default only for now)
x       mark scrollbar with finds (set color for multiple finds?)
x       save search & color as preset
x       trigger sets of presets based on command name
x       run command on current selection?
    text body context menu
      change format (reloads text)
      transform selection to table
o     adjustSize() --> autoresize window?
    command line options / open menu (menu bar)
*     source from stdin
*     file
!     command --> edit command in menu?


  log
!    saves to a log, either file or short memory buffer
!    buffer size = bytes and/or time or lines
     log format:
       START $pid command
       $pid output line
       EXIT $pid $exitval wait stats...
     view full or filtered log

  status icon? from logged job?

  simple output window
    for commands that output a small amount and exit in a short time
    rerun / close / clone / save
    pulldown: run this command with mode <> next time
    pulldown: (shared) / dedicated / clone / timeout (set as default for this cmd)

  log mode
    show icon initially (icon window? status bar?)
    open icon
      process status
      kill
      log view
      close --> icon
      detach / hide

  table
    options: --delimiter
    select lines, cells, columns, send back to editor
    show / hide / rearrange columns
    sort by column

  built in commands
!   terminal (--set-default)
*   scrolly
!   log
    simple --shared (default)
    simple --dedicated
    simple --clone
    table
    parse / display (pie?)
!   cd / pushd / popd ??
!   set environment / set from command output (modules)
    set command category (above list, default)
    name completion

    host (similar to cd) --> send commands to ssh
       use remote stub?
       pty password mode for sudo?

  predefined list of commands and types?
  autodetect by output size and runtime
  handle .desktop files, prepopulate graphical applications from those
