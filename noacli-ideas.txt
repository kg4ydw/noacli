noacli -- no ampersand asynchronous shell

o  started, partial implementation
*  done
!/ next
E  buggy
-  gui implelemented, no code
x  not supported in Qt


Things to implement soon:
? close stdin
  job: double click connect to send command to editor
o job life cycle
*   connect to qtail window status
*   delete job if command is done and window is closed
    timeout if no window?
* tables: implement vertical headers??
*   make corner button clickable to reset sort column to -1
* qtail: resize after visible? or after first read

  command parser
    prefix or suffix for output dest
      stdout:stderr
      > @qtail  2>@qtail
      default qtail:log
    handle |  --> tree
    handle <
    handle >
    set window title based on regex filter list
  update status bar with recent process status and errors
  short output in status window
  single lines to status bar (and status window?)

  job manager and hsitory:
    scroll to new entry
    resize columns

Bugs:
  gets middle of file on /usr/dict/words without --whole
? what to do with stderr? always log?
* scrollTo not working
  qtail gives useless errors on file not found
E settings dialog: checkbox doesn't work
* edit mask for simpleTable model
* lots of stuff packed into class noacli that could go elsewhere

context menu / widget / class
* history manager / historyView
  job manager / jobTableVew / noacli
  button editor / settingsDialog>tableView / settingsDialog
  general settings editor / settingsDialog>tableView / settingsDialog
  command window / plainTextEdit / commandEditor
  qtail search / searchTerm / QtTail?

Main features:
  main window is a dynamic one line editor
    pwd in message window when nothing else
    directory stack
*   complex commands are sent to bash
      detect complex commands
    command window context menu
      run
      clear?
      save to favorites
    Qsettings
       save/restore geometry (QWidget)
         save multiple profiles
*      save/restore history?
o      read history on command
       save env changes?
    docks* and +dialogs?  (%hash @array)
      dock: QT data structure is persistent and master
      dialog: build a table on the fly and save changes
*      *@ history
-      *% button bar
            right click: dump in editor
            draggable gridview ??
            reimplement compact button bar GUI and make its own checkbox
*      *? job manager
       !@ favorites editor (buttons and frequent)
       !% environment var editor
*      !% settings editor
       !% command default mode editor
            table: command mode
            mode: qtail log terminal null local graph (default: pulldown)
* history with arrow keys
  history search with ctrl-s ctrl-r and !?
* history with pull down menu (last 10)
* history manager
*   table: index frequency exitval command button-name checkbox:edit/run
*   editable table --> double click to edit in main window
*   exit value: none if never run; color green/red/grey
*   allow re-edits of unrun entries, move to end of list
*   sortable table (by col)
*   search box --> filter
*   sort: history order (col=-1)
*   context menu
? remember 10 most frequent commands in pull down menu
  button editor ("favorites")
    table: *name *key count *command *checkImmediate
    sorted sections: buttons freq
    mark edited lines and save? or just mark to keep or expire
    context menu: delete, duplicate?, run? prune
  history manager context menu
*   (single click copies to edit window, double click runs)
!   add to favorites
*   delete selected
*   remove duplicates
  job manager list
o   manager table: pid type command kill raise? info rerun
*   alternate: QProcess object, status, type, command
*   window status
    window type
*   click to redisplay / raise window (qtail)
    job manager context menu:
      info? --> process status, time stats, etc
      kill
      edit
      kill or kill and restart
o     raise or reopen
      close window
      measure output
      clone?
    open status icon
*   proc/wait info
*   delete dead jobs? (life cycle)
    change default type
  pipe / fd / job 
    handle stdout
      stderr channels separately
      save to file
      can a process in the middle of a pipeline be restarted?
    handle stdin:
      send file
      pipe  (connect multiple commands, tree style jobs)
?     close when not used
o settings
*   table: name default tooltip currentval
    show default in table ? or unmark when set to default?
    context menu: reset selected to default
*   merge qtail options
    items
*     historysize
*     historyfile
*     histfilesize
      histcontrol
        ignorespace : don't remember commands starting with space
o       ignoredups: ignore repeated commands
o       erasedups: remove previous occurances from history
*     JobMenuWidth
*     history menu size
      frequent menu size
      frequents size
      frequents threshold
!     SHELL external shell
      graphical terminal
      QTailFormat
      QTailFollow
      QTailWrap
      QTailSearchMode
      QTailCaseInsensitive
  environment vars?
    inherit for subprocs (active)
    inherited / modified
    save / session
    context menu
      import from external environment
      delete
      set as deleted --> save
      (column highlight) check/uncheck all
    checkboxes/settings
      external (inherit/ignore/replace)
      save settings (save/session only)
      export (pass to subproc) (activate/deactivate)


  short output commands -- display last line in editor/launcher


  terminal
o qtail window
  graphical window -- merged logs?
! merged log viewer
  table parser window
  iconified -- status from proc
  special -- parsed status
    pie chart for percentages / apt interaction
  ephemeral -- autoclose

o scrolly window
*   view / follow a log file
*   take input from a pipe
E   keep only last X lines? (initial input overload)
*   autoresize (need trigger event)
    in a file, button to backscroll to previous lines or read more forward
       large file handling, line number / fseek index
    pause (pull down menu) disable input / change button
*   start from top / follow tail
o   reload button
*     if file --> reload
*     if process / running command -> kill
      if done command -> rerun
/     if open stdin -> stop (close)
/     if closed -> close window
    autoclose after exit on specified timeout without user interaction
*   search / filter ?
    search context menu
o     find next
      find previous
      advanced --> find dialog
    menu bar
      file
        open: new / command / reopen/refresh / rerun / reopen file in other app
        save as
        buffering: tail [size] / all
        format/view
**x       plain text html markdown
x         fixed width font
o     memory saver (limit scrollback to 1M / 10000 lines by default)
      find menu
        advanced --> find dialog
*       wrap?
        bookmarks
      find dialog
        buttons: next prev hilight/unhilight
        regex / glob / plain ?
o       ignore case (default only for now)
x       mark scrollbar with finds (set color for multiple finds?)
x       save search & color as preset
x       trigger sets of presets based on command name
x       run command on current selection?
    text body context menu
x     change format (reloads text)
      transform selection to table
*     adjustSize() --> autoresize window?
    command line options / open menu (menu bar)
*     source from stdin
*     file


  log
!    saves to a log, either file or short memory buffer
!    buffer size = bytes and/or time or lines
     log format:
       START $pid command
       $pid output line
       EXIT $pid $exitval wait stats...
     view full or filtered log

  status icon? from logged job?

  simple output window
    for commands that output a small amount and exit in a short time
    rerun / close / clone / save
    pulldown: run this command with mode <> next time
    pulldown: (shared) / dedicated / clone / timeout (set as default for this cmd)

  log mode
    show icon initially (icon window? status bar?)
    open icon
      process status
      kill
      log view
      close --> icon
      detach / hide

  table
    options: --delimiter
    select lines, cells, columns, send back to editor
    show / hide / rearrange columns
    sort by column

  built in special commands
!   terminal (--set-default)
*   scrolly / qtail / tail
!   log
    direct run / sh wrapper
    
    simple --shared (default)
    simple --dedicated
    simple --clone
    table
    parse / display (pie?)
    (feature) name completion
    host (similar to cd) --> send commands to ssh
       use remote stub?
       pty password mode for sudo?
    button --> adds a button for the following command
    pushd dir --> creates button fur current directory and cd
    pushd * --> creates buttons for all listed directories

  built in standard commands
!   cd / pwd
!   set environment / set from command output (modules)
    set command category (above list, default)
    (feature) support commands for module
      source ?
      export
    disown --> disconnect job

  questional built in commands -- gui eqivs
    set / shopt / unset
    hash / type --> performance needed??
    jobs history --> pop up window?
    pushd popd dirs / dirstack --> use buttons instead?
    alias / unalias
    kill
    exit
    ulimit
    umask
    bind (key)
    builtin command enable disable
    help
    times
  useless builtins
    exec fg bg echo eval let local logout mapfile readarray printf suspend
  turing complete builtins
    break caller continue declare typeset getopts read readonly return shift test trap wait


  predefined list of commands and types?
  autodetect by output size and runtime
  handle .desktop files, prepopulate graphical applications from those

  fancy environment variable editor
    split on delimiter, default :
    turn into checkbox list
    allow dragging
    context menu
      select all/none
      remove duplicates
      sort

  command processor
    split
    check for built in commands
      immediate: cd pwd
      output mode: term(inal} log qtail tail
      parse mode: direct sh pipe ${usershell}
    if mode not set, guess
      multi-line --> sh
      regex match?
      match next word to category list
