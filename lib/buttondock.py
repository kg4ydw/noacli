
__license__   = 'GPL v3'
__copyright__ = '2022, 2023, Steven Dick <kg4ydw@gmail.com>'

from functools import partial

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.Qt import Qt, pyqtSignal

from lib.mydock import myDock
from lib.flowlayout import FlowLayout
from lib.datamodels import settingsDialog, simpleTable

# dock code originally generated by designer
# then trimmed to essentials and tweaked

class ButtonDock(myDock):
    docklist = {}
    favoritelist = {
        'Run' : 'Run',
        'Rerun last' : 'Rerun last'
    }
    special_buttons = ['Run', 'Rerun last']
    defaultDock = []
    run_command = pyqtSignal(str)
    def __init__(self, parent, title):
        ## mostly UI code
        super().__init__(parent)
        # each button dock remembers what buttons it wants
        self.mybuttons = {}
        self.setWindowTitle(title)
        self.setObjectName(title)
        self.docklist[title] = self
        if len(self.defaultDock)==0: # make the first the default
            self.defaultDock.append(self)
            self._fixup(self.run_command)
            self.firstDock = True # never delete this
        self.setFeatures(QtWidgets.QDockWidget.AllDockWidgetFeatures)
        self.buttonBox = QtWidgets.QWidget()
        self.mylayout = FlowLayout(self.buttonBox)
        self.mylayout.setContentsMargins(0, 0, 0, 0)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHeightForWidth(self.mylayout.hasHeightForWidth())
        self.buttonBox.setSizePolicy(sizePolicy)
        self.buttonBox.setObjectName("buttonBox")
        self.setWidget(self.buttonBox)
        parent.addDockWidget(QtCore.Qt.DockWidgetArea(4), self) # XXXX
        if self.defaultDock[0]==self:
            # default dock always gets run buttons
            for i in self.special_buttons:
                b = self.addButton(i)
        else:
            # add to parent's view menu if this isn't the default dock XXX
            self.defaultDock[0].parent().ui.menuViews.addAction(self.toggleViewAction())

    @classmethod
    def setAllVisibility(cls, vis):
        for i in cls.docklist:
            cls.docklist[i].setVisible(vis)

    @classmethod
    def tabifyAll(cls, main, prev):
        for i in sorted(cls.docklist):
            if cls.docklist[i]!=prev:
                main.tabifyDockWidget(prev, cls.docklist[i])
                prev = cls.docklist[i]
            else:
                print('skip '+i)
      
    @classmethod
    def _fixup(cls, sig):
        # overwrite unbound signal with a bound one from the default dock
        cls.run_command = sig

    def contextMenuEvent(self, event):
        child =  self.childAt(event.pos())
        if child and not hasattr(child,'text'): child=None
        m = QtWidgets.QMenu()
        m.addAction("Edit buttons", partial(EditButtonDocks,self))
        ##XXX need class instance#  m.addAction("Edit favorites", partial(Favorites.editFavorites,None))
        m.addAction("Unconstrained order", self.mylayout.unsorted)
        m.addAction("Alphabetize", self.mylayout.alphasort)
        m.addAction("Greedy fit", self.mylayout.greedy)
        #m.addAction("Update", self.mylayout.update)
        if child:
            # XXX copy command to commandEditor ?
            m.addAction("Delete button "+child.text(), partial(self.delButton, child.text()))
        if self != self.defaultDock[0]:
            m.addAction("Set as default dock", self.setDefaultDock)
            if not self.mybuttons and not hasattr(self, 'firstDock'):
                m.addAction("Delete this dock", self.delDock)
        m.exec(event.globalPos())

    def doButton(self, name, clicked=None):
        c = self.favoritelist[name]
        if type(c)==str: # special buttons
            self.run_command.emit(c)
        else:
            c.runme()

    def setDefaultDock(self):
        self.defaultDock[0] = self

    @classmethod
    def updateFavs(cls, newfav, changed=None):
        delme = set(cls.favoritelist.keys()) - set(newfav.keys()) - set(set(cls.special_buttons))
        # delete removed favorite buttons
        for f in delme:
            del cls.favoritelist[f]
        for f in delme:
            for d in cls.docklist:
                cls.docklist[d].delButton(f)
        # update remaining buttons, add new buttons to default dock
        if changed==None: # assume everything changed
            changed = set(newfav.keys())
        for f in newfav:
            if f in cls.favoritelist:
                if  f in changed:
                    cls.favoritelist[f] = newfav[f]
                    # update it everywhere
                    for d in cls.docklist:
                        dock = cls.docklist[d]
                        if f in dock.mybuttons:
                            if type(dock.mybuttons)==str:
                                # make a real button
                                dock.addButton(f)
                            else: # update old button
                                dock.setButton(f)
            else:  # new button, add to default dock
                cls.favoritelist[f] = newfav[f]
                cls.defaultDock[0].addButton(f)

    def delButton(self, button):
        if button not in self.mybuttons: return
        b = self.mybuttons[button]
        del self.mybuttons[button]
        if type(b)==str: return
        self.mylayout.removeWidget(b)
        b.setParent(None)

    def addButton(self, button):
        # if the favorite isn't loaded yet, make a fake button and punt
        if button not in self.favoritelist:
            if button not in self.mybuttons: # but leave existing alone
                self.mybuttons[button] = button
            return
        # if button already exists, don't re-add it
        if button in self.mybuttons and type(self.mybuttons[button])!=str:
            # this *shouldn't* be recursive but it might be
            return self.setButton(button)
        # XX if there was a button by this name, step on it
        b = QtWidgets.QToolButton(self)
        if type(self.favoritelist[button])==str:
            # make this sort first
            b.setObjectName('@'+button)
        else:
            b.setObjectName(button)
        b.setText(button)
        self.mybuttons[button] = b

        if type(self.favoritelist[button])==str:
            # this never changes, just do it here
            if button in self.special_buttons:
                b.setStyleSheet("""QToolButton:!pressed { border: 1px solid black; border-radius: 6px; font-weight: bold; }""")
            if button=='Run':
                b.setToolTip('Run command currently being edited')
            elif button=='Rerun last':
                b.setToolTip("Rerun previous command")
        else:
            self.setButton(button)
        b.clicked.connect(partial(self.doButton,button))
        self.mylayout.addWidget(b)
        return b

    def setButton(self, button):
        b = self.mybuttons[button]
        if button not in self.favoritelist: return # not yet
        if type(self.favoritelist[button])==str: return
        if type(b)==str:
            if button in self.favoritelist:
                return self.addButton(button)
            else:
                return
        b.setObjectName(button)
        f = self.favoritelist[button]
        b.setToolTip(f.command)
        if f.immediate:
            b.setStyleSheet("QToolButton { font-weight: bold; }")
        else:
            b.setStyleSheet("QToolButton { font-style: italic; }")

    @classmethod
    def addDock(cls, name):
        if name  in cls.docklist:
            return cls.docklist[name]
        else:
            return ButtonDock(ButtonDock.defaultDock[0].parent(), name)

    def delDock(self):
        if self.mybuttons: return # delete buttons first
        if hasattr(self, 'firstDock'): return # can't delete first dock
        if self.defaultDock[0]==self: return # can't delete default
        name = self.objectName()
        del self.docklist[name]
        qs = QtCore.QSettings()
        qs.beginGroup('buttondocks')
        qs.remove(name)
        qs.endGroup()
        self.deleteLater()

    @classmethod
    def loadSettings(cls):
        # XXX what about default dock
        qs = QtCore.QSettings()
        qs.beginGroup('buttondocks')
        docks = qs.childKeys()
        for dockname in docks:
            buttons =  qs.value(dockname, [])
            if not buttons: continue # delete empty docks
            dock = cls.addDock(dockname)
            for button in buttons:
                if button not in cls.favoritelist:
                    cls.favoritelist[button] = button # fake entry
                dock.addButton(button)
        qs.endGroup()
        if 'orphans' in cls.docklist:
            # if you don't want this hidden, save the geometry
            cls.docklist['orphans'].hide()

    @classmethod
    def saveSettings(cls):
        qs = QtCore.QSettings()
        # XXX what about default dock
        # all buttons must be in a dock or orphaned ones end up on the default dock
        orphans = set(cls.favoritelist.keys())
        qs.beginGroup('buttondocks')
        for dockname in sorted(cls.docklist.keys()):
            if dockname=='orphans': continue
            dock = cls.docklist[dockname]
            buttons = list(dock.mybuttons.keys())
            orphans -= set(buttons)
            if not buttons:
                qs.remove(dockname)
                continue
            qs.setValue(dockname,buttons) # XX sort order??
        if 'orphans' in cls.docklist: # SETTING
            # add back in orphans in case the user really wants this
            orphans |= set(cls.docklist['orphans'].mybuttons.keys())
        if orphans:
            qs.setValue('orphans',sorted(orphans))
        qs.endGroup()

class EditButtonDocks(settingsDialog):
    def __init__(self, parent, doneFunc=None):
        self.doneFunc = doneFunc
        data = []
        # put the default dock first
        defdock = ButtonDock.defaultDock[0].objectName()
        docks =  [defdock] + sorted([x for x in ButtonDock.docklist.keys() if x!=defdock])
        buttons = set(ButtonDock.favoritelist.keys())-set(ButtonDock.special_buttons)
        buttons = ButtonDock.special_buttons+ sorted(buttons)
        for button in buttons:
            data.append([button in ButtonDock.docklist[di].mybuttons
                                  for di in docks])
        model = simpleTable(data,docks,
                            datatypesrow =[bool]*len(docks),
                            editmask = [True]*len(docks))
        model.vheaders = buttons
        self.ebuttons = buttons
        self.edata = data
        self.edocks = docks
        super().__init__(parent, "Button dock editor", model)
        self.ui.tableView.horizontalHeader().setStretchLastSection(False)
        self.ui.tableView.resizeColumnsToContents()
        self.finished.connect(self.finishEdit)
        buttonbox = self.ui.buttonBox
        newdia = buttonbox.addButton("New dock", QtWidgets.QDialogButtonBox.ActionRole)
        newdia.clicked.connect(self.addDock)
        tv =  self.ui.tableView
        tv.setContextMenuPolicy(Qt.CustomContextMenu)
        tv.customContextMenuRequested.connect(self.contextMenu)

    def selectionSetCheck(self, state):
        # XX make sure index is from base model not proxy
        selected = self.ui.tableView.selectionModel().selection().indexes()
        for index in selected:
            row = index.row()
            col = index.column()
            if state==None: # toggle
                self.edata[row][col] = not self.edata[row][col]
            else:
                self.edata[row][col] = state
            self.model.dataChanged.emit(index, index)
    
    def contextMenu(self, point):
        # attach this to tableView
        t = self.ui.tableView
        # index = t.indexAt(point) use for delete and set default
        #if not index.isValid(): return
        sm = t.selectionModel()
        if not sm.hasSelection(): return # or index (later)
        m = QtWidgets.QMenu(self)
        if sm.hasSelection():
            m.addAction("Check selected", partial(self.selectionSetCheck, True))
            m.addAction("Clear selected", partial(self.selectionSetCheck, False))
            m.addAction("Toggle selected", partial(self.selectionSetCheck, None))
        # XXXX buttondock context menu
        # delete dock (confirm?)
        # set default dock
        m.exec(t.mapToGlobal(point))
    
    def addDock(self):
        (name, result) = QtWidgets.QInputDialog.getText(self, "Add new button dock", "Button dock name")
        if name:
            name = name.replace('/', ' ') # slashes don't work well
            name=name.strip()
        if not result or not name or len(name)<1:
            return
        if name in self.edocks: return  # XX silent error
        ButtonDock.addDock(name)
        coldata = [True, True] + ([False]*(len(self.edata)-2))
        self.model.appendColumn(name,coldata)
        self.ui.tableView.resizeColumnToContents(len(self.edocks))
    
    def finishEdit(self, result):
        if result:
            for di in range(len(self.edocks)):
                dock = ButtonDock.docklist[self.edocks[di]]
                for bi in range(len(self.ebuttons)):
                    button = self.ebuttons[bi]
                    if (button in dock.mybuttons) != self.edata[bi][di]:
                        if button in dock.mybuttons:
                            dock.delButton(button)
                        else:
                            dock.addButton(button)
            ButtonDock.saveSettings()
        # release resources
        self.edata = None
        self.ebuttons = None
        self.emodel = None
        self.setParent(None) # XX delete later?
        self.edocks = None
        if self.doneFunc: self.doneFunc()
        
